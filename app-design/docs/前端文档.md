# P2P 直连文件发送应用 - 前端可行性分析与实现方案

## 1. 结论摘要
作为一名前端专家，评估结论为：**纯浏览器端的前端技术不仅完全具备横向落地并消化本需求的能力，更是整个项目的绝对核心驱动力。** 后端在这个项目中仅扮演极为边缘的“信令牵线搭桥”角色。前端将统揽包含文件读取切片、网络穿透直连、流量与缓冲控制在内的所有深水区操作。

## 2. 核心技术痛点与前端应对策略

### 2.1 极大文件内存挤兑问题（Blob 切片流处理）
浏览器不是传统桌面应用，一次性读入一个 5GB 或更庞大的视频文件进入内存 `ArrayBuffer` 必定会导致浏览器页面标签崩溃 (OOM)。
- **我们的解法**：全面拥抱 HTML5 的 `File`/`Blob` API 进行流式读取。在发送文件时，不执行 `FileReader.readAsArrayBuffer(file)`（一次性读取全量），而是根据 WebRTC 发送口的流控阀门，按 `chunkSize` (如通常设置在 `16KB - 64KB` 之间) 使用 `file.slice(offset, offset + chunkSize)` 边读边装包边利用 WebRTC 实时发送。

### 2.2 WebRTC 数据通道的缓冲膨胀控制 (Bufferbloat 限流)
新手实现 WebRTC 文件传输时经常会犯的错误是：`while` 循环直接疯狂向 `RTCDataChannel.send()` 里灌入数据，导致底层协议栈缓冲区堆积直接拉爆抛错崩溃。
- **我们的解法**：前端必须实现一个**智能发包控制器**，监听 DataChannel 原生的 `bufferedamountlow` 事件，并查询 `channel.bufferedAmount` 属性。仅当通道缓冲区排队的数据量低于预设的水位线低位时，才进行下一批分片的读取和注入（背压 Backpressure 机制）。

### 2.3 超大文件的落盘缓存策略 (File System Access API & Streams API)
当纯前端接收超大型文件数据时，数据存在哪里？
- 旧方案是塞入 `URL.createObjectURL(new Blob(...))`，依旧存在着内存爆炸痛点。
- **现代前沿解法（重点引入的可行策略）**：
  1. 优先采用 Chrome 等现代内核支持的 **`File System Access API`** (`showSaveFilePicker`)。在接收的一开始，就让用户选择电脑本地的保存位置获取 `FileSystemWritableFileStream` 句柄，然后将 WebRTC 收到的切片一边接收一边以**原生流**的形式立刻写入硬盘，不占用任何内存。
  2. Fallback 备选方案：通过流式的 Service Worker 拦截模拟下载流，或者利用 `IndexedDB` 暂存临时分块，完成后拼接唤起传统下载。

### 2.4 实现复杂的心跳与断连感知 (Ping-Pong)
断线重连不能傻乎乎依赖 WebRTC API 时而迟钝的自带掉线通知（由于有些 NAT 结构导致的半死连状态，底层 API 长达十几秒才触发状态变更）。
- **我们的解法**：在前端应用内部，在 `DataChannel` 里封装逻辑层的心跳协议。发送和接收端定期（如 3秒）往通道内抛射极轻量的 `PING/PONG` 包。若长达 6 秒无回调响应，立刻在 UI 层面封锁进度条，判为假死而转入断线断点重连挽救机制。

## 3. UI/UX 前端交互评估
Vue 3 组合式 API 将在这个场景下发挥无可比拟的解耦优势。
建议通过 `useWebRTC()`, `useSignaling()`, `useFileTransfer()` 的顶级组合式可组合函数 (Composables) 来将复杂的底层回调异步状态（如进度率、网络速度、设备名）彻底转化为响应式数据 (Refs)。UI 组件层面变得非常轻量：仅仅通过 `v-if/v-else` 和进度条绑定这些响应式 Refs 即刻。
为了追求卓越的高级前端美感，我们将使用 Tailwind CSS 构筑具备大面积留白与微动画的沉浸式极简页面传输视图。
