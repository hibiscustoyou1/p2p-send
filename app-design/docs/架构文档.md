# P2P 直连文件发送应用 - 技术架构设计文档

## 1. 架构概览与核心协议
本项目是一个典型的 Web P2P (Peer-to-Peer) 应用，不涉及大容量的数据持久化或服务端大带宽转发。主要依靠客户端浏览器原生的算力和网络直连能力进行重负载的数据交互。

核心底层依赖：
- **WebRTC (`RTCDataChannel`)**：负责两端浏览器之间直接的可靠/不可靠数据传输通道建立。
- **WebSocket**：作为信令（Signaling）协议，用于 A 和 B 互相找到对方，并交换建立直连必需的协商数据（Offer、Answer、ICE Candidates）。
- **STUN/TURN 服务器**：用于 NAT 穿透。帮助处于局域网或内网的浏览器发现自身的公网 IP；若极端网络环境无法打洞直连，则由 TURN 服务器进行数据流量的中继（Relay）。

## 2. 系统组件划分

整个架构分为三大核心中心：

### 2.1. 客户端 (Web App)
- **UI 交互层**：负责邀请码展示、拖拽文件、进度条渲染、传输状态监控。
- **文件切片读取器 (File Slicer)**：使用 `File API` (`Blob.slice()`) 将几百MB乃至上GB的大文件，切分为小数据块（例如每个 Chunk `64KB` 或 `256KB`），边读边发，极大地降低内存占用。
- **WebRTC 引擎 (Connection Manager)**：负责与信令服务器交互，维持或重建 P2P 隧道，并在 DataChannel 上封装上层协议（如分片带有序列号、校验机制等，来实现断点续传的流控）。

### 2.2. 信令服务器 (Signaling Server)
- **职责**：极其轻量级的中心节点。它只是一台配置了 WebSocket 的服务器（如 Node.js Socket.io/ws）。
- **功能**：
  1. 维护在线设备的 `Socket.id` 会话。
  2. 实现基于类似 `房间制 (Room)` 的概念。邀请码即为 `Room ID`。
  3. 当 A 创建房间并生成代码，B 加入同一个代码的房间时，该服务器将 A 的 SDP (Session Description Protocol) 转发给 B，将 B 的回应转发给 A。
  4. 绝不参与真实的文件数据转发。

### 2.3. ICE 穿透基础设施 (NAT Traversal)
- 部署开源的 STUN/TURN 软件（如经典方案 `coturn`）。
- **重要考虑**：在国内复杂的网络环境（如多层对称型 NAT）中，纯靠 STUN 打洞成功率并非 100%。必须配置自建的 TURN 服务器作为兜底（Fall back）。如果直连完全不可行，流量将会通过自建 TURN 服务器中转，此时会占用服务商的上行带宽。

## 3. 技术栈选型推荐

鉴于当前项目为 `apps/server`, `apps/client` 和 `packages/shared` 的 Monorepo 体系，以下技术栈能完美契合当前工程范式：

*   **前端应用 (`apps/client`)**:
    *   **核心框架**: `Vue 3` (Composition API) 结合 Vite 极速构建。
    *   **状态管理**: `Pinia` (应对复杂的连接状态、多文件传输状态的任务队列分发极其便利)。
    *   **P2P/信令库**: 可使用 `simple-peer` 简化底层的 WebRTC 繁杂 API 操作，或者直接使用原生 `RTCPeerConnection` 以获得最高的断线重连控制度。
    *   **实时通信**: `Socket.io-client` 配合后端的信令服务。
*   **共享库 (`packages/shared`)**:
    *   定义 WebSocket 的事件枚举（`JOIN_ROOM`, `SIGNAL`, `PEER_LEFT` 等）。
    *   定义文件分片协议（Chunk Headers：如 `{ fileId: "xxx", chunkIndex: 12, data: <ArrayBuffer> }`）。
*   **后端服务 (`apps/server`)**:
    *   **运行时/框架**: Node.js + Express + `Socket.io` 搭建承载万级并发无状态连接的信令网关。
    *   **缓存/状态**: 由于需高可用的快速查询六位邀请码是否存在，初期可以仅使用内存变量 `Map` 或 `Set`，进阶扩展可接入 `Redis` 用于多实例间的横向拓展。

## 4. 解决“断连恢复”的逻辑设计

为了支撑需求中提到的断线重连与断点续传功能：
1. **统一文件指纹 (Fingerprint)**：A 在决定发送文件时，通过文件名称、修改时间 `lastModified` 和总字节数 `size`（甚至可以引入快速的 SHA256 头部哈希计算）生成一个全网唯一的 `fileID`。
2. **切片清单 (Bitfield/ACK 机制)**：接收方 B 在将 ArrayBuffer 写入本地计算机的同时，在 `IndexedDB` 中或内存中记录“已成功完好的切片索引集合”。
3. **断联恢复协议**：当 A 和 B 后续再次接通 WebRTC 后，B 会作为请求方，向 A 发放指令：`REQ_RESUME { fileID: 'xxx', ackedChunks: [1...435, 437...809] }`。
4. **精确发送**：发送端 A 解析指令后，跳过已经被 ACK 过的文件分片，精准向外抛出未被成功接收及在网络断层中丢失的分片。
